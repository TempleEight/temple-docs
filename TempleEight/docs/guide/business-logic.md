---
id: business-logic
title: Adding business logic to your service 
sidebar_label: Business Logic 
---

We know that the code generated by Temple won't necessarily satisfy every use case.
That's why we made it easy to modify and extend the application logic, without sacrificing the ability to regenerate code after.
This short guide will walk you through how to add custom business logic to your application, as well as additional endpoints.
We'll be using the `ExampleProject` from the [getting started guide](getting-started.md), and we'll assume you have a basic familiarity with Go syntax.

## Adding custom logic
In the `example-service` directory, you'll find the following files and folders:
```
~/Documents/temple-tutorial ❯❯❯ ls -1 example-service
Dockerfile
config.json
dao
example-service.go
go.mod
hook.go
setup.go
util
```

We're most interested in `setup.go` for this guide, which is where you can add additional logic that won't be lost if you need to regenerate your Templefile.

This file should start off looking fairly empty:

```go
package main

import "github.com/gorilla/mux"

func (env *env) setup(router *mux.Router) {
	// Add user defined code here
}
```

The `setup` method defined on `env` here is invoked before the HTTP server is started.
It gives you, the developer, the opportunity to:

- register hooks, to be executed before or after any database calls
- register new endpoints with the router

Hooks provide an interface for you to define custom logic that is executed before or after a specific database interaction.
This may include logic for additional validation of request parameters or providing values to be stored that are not included in the request (see [value annotations](value-annotations.md) for more on this).

## Registering a hook 
Within the `env` object that the `setup` method is defined on, you will find an attribute called `hook`.
Hook is a struct that is defined in `hook.go`, which defines two methods for each endpoint:

```go
func (h *Hook) BeforeCreate(hook func(env *env, req createExampleServiceRequest, input *dao.CreateExampleServiceInput) *HookError) {
  ...
}

func (h *Hook) AfterCreate(hook func(env *env, exampleService *dao.ExampleService) *HookError) {
  ...
}

```
By defining a function that matches the argument type defined here, we are able to execute arbitrary code before or after the datastore interaction for each endpoint.
The types of each hook vary, depending on the operation they are defined on.
Where a request body is not provided, such as in a GET request, the `req` argument is ommited from the hook.


We are able to define a hook that is executed before an object is created, by modifying `setup.go` to read:

```go
package main

import (
	"github.com/gorilla/mux"
	"github.com/temple/tutorial/example-service/dao"
)

func (env *env) setup(router *mux.Router) {
	env.hook.BeforeCreate(beforeCreateHook)
}

func beforeCreateHook(env *env, req createExampleServiceRequest, input *dao.CreateExampleServiceInput) *HookError {
	return nil
}
```

// TODO
## Modifying the DAO request

## Modifying the response to the client

## Making additional DAO calls

## Aborting Requests

## Registering a new endpoint with the router
